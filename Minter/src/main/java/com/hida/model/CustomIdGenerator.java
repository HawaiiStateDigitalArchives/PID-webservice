package com.hida.model;

import static com.hida.model.IdGenerator.Rng;
import static com.hida.model.IdGenerator.LOGGER;
import java.util.Set;
import java.util.TreeSet;

/**
 * An Id Generator that creates Pids. For each Pid, every digit in their names
 * will be created using the possible characters provided by a character map.
 * Each digit in a character map references a different TokenType object.
 *
 *
 * @author lruffin
 */
public class CustomIdGenerator extends IdGenerator {

    /**
     * The mapping used to describe range of possible characters at each of the
     * id's root's digits. There are total of 5 different ranges that a charMap
     * can contain:
     *
     * <pre>
     * d: digits only
     * l: lower case letters only
     * u: upper case letters only
     * m: letters only
     * e: any valid character specified by d, l, u, and m.
     * </pre>
     *
     */
    private String CharMap;

    /**
     * An array of Strings that contains the possible characters at each index
     * of Pid's root name. This field is generated by CharMap.
     */
    private final String[] TokenMap;

    /**
     * A variable that will affect whether or not vowels have the possibility of
     * being included in each id.
     */
    private boolean SansVowel;

    /**
     * Instantiates an Id Generator that creates Pids primarily based on a
     * charMap. The only valid charMap characters are regex("[dlume]+"). No
     * restrictions are placed on the other parameters.
     *
     * @param prefix A sequence of characters that appear in the beginning of
     * PIDs
     * @param sansVowel Dictates whether or not vowels are allowed
     * @param charMap A sequence of characters used to configure Pids
     */
    public CustomIdGenerator(String prefix, boolean sansVowel, String charMap) {
        super(prefix);
        this.CharMap = charMap;
        this.TokenMap = new String[charMap.length()];
        this.SansVowel = sansVowel;

        initializeTokenMap();
    }

    /**
     * Creates Pids without regard to a natural order.
     *
     * @param amount The number of Pids to be created
     * @return A set of Pids
     */
    @Override
    public Set<Pid> randomMint(long amount) {
        // checks to see if its possible to produce or add requested amount of
        long total = calculatePermutations();
        if (total < amount) {
            throw new NotEnoughPermutationsException();
        }
        // generate ids        
        Set<Pid> pidSet = new TreeSet<>();

        for (int i = 0; i < amount; i++) {
            String name = Prefix;
            for (String map : TokenMap) {
                int randomNumber = Rng.nextInt(map.length());
                name += map.charAt(randomNumber);
            }

            Pid pid = new Pid(name);
            while (!pidSet.add(pid)) {
                this.incrementPid(pid);
            }

            LOGGER.trace("Generated Custom Random ID: {}", pid);
        }
        
        return pidSet;
    }

    /**
     * Creates Pids in ascending order
     *
     * @param amount The number of PIDs to be created
     * @return A set of Pids
     */
    @Override
    public Set<Pid> sequentialMint(long amount) {
        // checks to see if its possible to produce or add requested amount of
        long total = calculatePermutations();
        if (total < amount) {
            throw new NotEnoughPermutationsException();
        }

        // create a set to contain Pids
        Set<Pid> pidSet = new TreeSet<>();

        // create a base Pid using the first character of the TokenType 
        String baseName = "";
        for (int i = 0; i < CharMap.length(); i++) {
            String map = TokenMap[i];
            baseName += map.charAt(0);           
        }        
        Pid basePid = new Pid(Prefix + baseName);
         
        for (int i = 0; i < amount; i++) {
            
            // copy the Name of basePid into a new Pid instance
            Pid pid = new Pid(basePid);
            
            // add the pid to the set
            pidSet.add(pid);
            
            // increment the base Pid
            this.incrementPid(basePid);
            LOGGER.trace("Generated Custom Sequential ID: {}", pid);
        }
        return pidSet;
    }

    /**
     * This method calculates and returns the total possible number of
     * permutations using the values given in the constructor.
     *
     * @return number of permutations
     */
    @Override
    public long calculatePermutations() {
        long totalPermutations = 1;
        for (int i = 0; i < CharMap.length(); i++) {
            if (CharMap.charAt(i) == 'd') {
                totalPermutations *= 10;
            }
            else if (CharMap.charAt(i) == 'l' || CharMap.charAt(i) == 'u') {
                totalPermutations *= (SansVowel) ? 20 : 26;
            }
            else if (CharMap.charAt(i) == 'm') {
                totalPermutations *= (SansVowel) ? 40 : 52;
            }
            else if (CharMap.charAt(i) == 'e') {
                totalPermutations *= (SansVowel) ? 50 : 62;
            }
        }
        return totalPermutations;
    }

    /**
     * Initializes TokenMap to contain a String of characters at each index to
     * designate the possible values that can be assigned to each index of a
     * Pid's BaseMap.
     */
    private void initializeTokenMap() {
        for (int i = 0; i < TokenMap.length; i++) {
            // get char
            char c = CharMap.charAt(i);

            // assign each index a string of characters
            if (c == 'd') {
                TokenMap[i] = TokenType.DIGIT.getCharacters();
            }
            else if (c == 'l') {
                TokenMap[i] = (SansVowel) ? TokenType.LOWER_CONSONANTS.getCharacters()
                        : TokenType.LOWER_ALPHABET.getCharacters();
            }
            else if (c == 'u') {
                TokenMap[i] = (SansVowel) ? TokenType.UPPER_CONSONANTS.getCharacters()
                        : TokenType.UPPER_ALPHABET.getCharacters();
            }
            else if (c == 'm') {
                TokenMap[i] = (SansVowel) ? TokenType.MIXED_CONSONANTS.getCharacters()
                        : TokenType.MIXED_ALPHABET.getCharacters();
            }
            else {
                TokenMap[i] = (SansVowel) ? TokenType.MIXED_CONSONANTS_EXTENDED.getCharacters()
                        : TokenType.MIXED_ALPHABET_EXTENDED.getCharacters();
            }
        }
    }

    /**
     * Increments a value of a PID. If the maximum limit is reached the values
     * will wrap around.
     *
     * @param pid The pid to increment
     */
    @Override
    public void incrementPid(Pid pid) {
        String name = pid.getName();
        int lastIndex = name.length() - 1;
        int prefixLength = Prefix.length();
        int tokenMapIndex = TokenMap.length - 1;
        boolean overflow = true;

        // continue until overflow is false or last value of the rootName is reached
        for (int i = 0; i <= lastIndex - prefixLength && overflow; i++) {
            int offset = lastIndex - i;
            String map = TokenMap[tokenMapIndex - i];
            char c = name.charAt(offset);
            char firstChar = map.charAt(0);
            char lastChar = map.charAt(map.length() - 1);

            if (c == lastChar) {
                pid.replace(offset, firstChar);
            }
            else {
                int position = map.indexOf(c);
                char nextChar = map.charAt(position + 1);

                pid.replace(offset, nextChar);
                overflow = false;
            }
        }        
    }

    /* getters and setters */
    public String getCharMap() {
        return CharMap;
    }

    public void setCharMap(String CharMap) {
        this.CharMap = CharMap;
    }

    public boolean isSansVowel() {
        return SansVowel;
    }

    public void setSansVowel(boolean SansVowel) {
        this.SansVowel = SansVowel;
    }
}
