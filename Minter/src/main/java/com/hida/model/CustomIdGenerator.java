package com.hida.model;

/**
 * An Id Generator that creates Pids. For each Pid, every digit in their names
 * will be created using the possible characters provided by a character map.
 * Each digit in a character map references a different Token object.
 *
 *
 * @author lruffin
 */
public class CustomIdGenerator extends IdGenerator {

    /**
     * The mapping used to describe range of possible characters at each of the
     * id's root's digits. There are total of 5 different ranges that a charMap
     * can contain:
     *
     * <pre>
     * d: digits only
     * l: lower case letters only
     * u: upper case letters only
     * m: letters only
     * e: any valid character specified by d, l, u, and m.
     * </pre>
     *
     */
    private String CharMap;

    /**
     * An array of Strings that contains the possible characters at each index
     * of Pid's root name. This field is generated by CharMap.
     */
    private final String[] TokenMap;

    /**
     * A variable that will affect whether or not vowels have the possibility of
     * being included in each id.
     */
    private boolean SansVowel;

    /**
     * Instantiates an Id Generator that creates Pids primarily based on a
     * charMap. The only valid charMap characters are regex("[dlume]+"). No
     * restrictions are placed on the other parameters.
     *
     * @param prefix A sequence of characters that appear in the beginning of
     * PIDs
     * @param sansVowel Dictates whether or not vowels are allowed
     * @param charMap A sequence of characters used to configure Pids
     */
    public CustomIdGenerator(String prefix, boolean sansVowel, String charMap) {
        super(prefix);
        this.CharMap = charMap;
        this.TokenMap = new String[charMap.length()];
        this.SansVowel = sansVowel;
        this.MaxPermutation = getMaxPermutation();
        
        initializeTokenMap();
    }
    
    /**
     * This method calculates and returns the total possible number of
     * permutations using the values given in the constructor.
     *
     * @return number of permutations
     */
    @Override
    final public long getMaxPermutation() {
        long totalPermutations = 1;
        for (int i = 0; i < CharMap.length(); i++) {
            if (CharMap.charAt(i) == 'd') {
                totalPermutations *= 10;
            }
            else if (CharMap.charAt(i) == 'l' || CharMap.charAt(i) == 'u') {
                totalPermutations *= (SansVowel) ? 20 : 26;
            }
            else if (CharMap.charAt(i) == 'm') {
                totalPermutations *= (SansVowel) ? 40 : 52;
            }
            else if (CharMap.charAt(i) == 'e') {
                totalPermutations *= (SansVowel) ? 50 : 62;
            }
        }
        return totalPermutations;
    }

    /**
     * Initializes TokenMap to contain a String of characters at each index to
     * designate the possible values that can be assigned to each index of a
     * Pid's BaseMap.
     */
    private void initializeTokenMap() {
        for (int i = 0; i < TokenMap.length; i++) {
            // get char
            char c = CharMap.charAt(i);

            // assign each index a string of characters
            if (c == 'd') {
                TokenMap[i] = Token.DIGIT.getCharacters();
            }
            else if (c == 'l') {
                TokenMap[i] = (SansVowel) ? Token.LOWER_CONSONANTS.getCharacters()
                        : Token.LOWER_ALPHABET.getCharacters();
            }
            else if (c == 'u') {
                TokenMap[i] = (SansVowel) ? Token.UPPER_CONSONANTS.getCharacters()
                        : Token.UPPER_ALPHABET.getCharacters();
            }
            else if (c == 'm') {
                TokenMap[i] = (SansVowel) ? Token.MIXED_CONSONANTS.getCharacters()
                        : Token.MIXED_ALPHABET.getCharacters();
            }
            else {
                TokenMap[i] = (SansVowel) ? Token.MIXED_CONSONANTS_EXTENDED.getCharacters()
                        : Token.MIXED_ALPHABET_EXTENDED.getCharacters();
            }
        }
    }

    /**
     * Increments a value of a PID. If the maximum limit is reached the values
     * will wrap around.
     *
     * @param pid The pid to increment
     */
    @Override
    public void incrementPid(Pid pid) {
        long next = (this.PidToLong(pid) + 1) % this.MaxPermutation;
        pid.setName(this.longToName(next));        
    }

    /**
     * Translates an ordinal number into a sequence of characters with a radix
     * based on TokenType.
     *
     * @param ordinal The nth position of a permutation
     * @return The sequence at the nth position
     */
    @Override
    protected String longToName(long ordinal) {
        StringBuilder name = new StringBuilder("");
        int fullNameLength = CharMap.length() + Prefix.length();

        long remainder = ordinal;
        for (int i = fullNameLength - 1; i >= Prefix.length(); i--) {
            String map = TokenMap[i - Prefix.length()];
            int radix = map.length();
            name.insert(0, map.charAt((int) remainder % radix));

            remainder /= radix;
        }
        
        return Prefix + name.toString();
    }

    /**
     * Translates a Pid into an ordinal number.
     *
     * @param pid A persistent identifier
     * @return The ordinal number of the Pid
     */
    @Override
    protected long PidToLong(Pid pid) {
        String name = pid.getName();
        int fullNameLength = CharMap.length() + Prefix.length();
        int totalRadix = 1;

        long ordinal = 0;
        for (int i = fullNameLength - 1; i >= Prefix.length(); i--) {
            String map = TokenMap[i - Prefix.length()];            
            int mapIndex = map.indexOf(name.charAt(i));
            int currentRadix = map.length();
                        
            ordinal += totalRadix * mapIndex;
            totalRadix *= currentRadix;
        }

        return ordinal;
    }

    /* getters and setters */
    public String getCharMap() {
        return CharMap;
    }

    public void setCharMap(String CharMap) {
        this.CharMap = CharMap;
    }

    public boolean isSansVowel() {
        return SansVowel;
    }

    public void setSansVowel(boolean SansVowel) {
        this.SansVowel = SansVowel;
    }
}
