package com.hida.model;

import static com.hida.model.IdGenerator.Rng;
import static com.hida.model.IdGenerator.LOGGER;
import java.util.Set;
import java.util.TreeSet;

/**
 * An Id Generator that creates Pids. For each Pid, every digit in their names
 * will be created using the possible characters provided by a character map.
 * Each digit in a character map references a different Token object.
 *
 *
 * @author lruffin
 */
public class CustomIdGenerator extends IdGenerator {

    /**
     * The mapping used to describe range of possible characters at each of the
     * id's root's digits. There are total of 5 different ranges that a charMap
     * can contain:
     *
     * <pre>
     * d: digits only
     * l: lower case letters only
     * u: upper case letters only
     * m: letters only
     * e: any valid character specified by d, l, u, and m.
     * </pre>
     *
     */
    private String CharMap;

    /**
     * An array of Strings that contains the possible characters at each index
     * of Pid's root name. This field is generated by CharMap.
     */
    private final String[] TokenMap;

    /**
     * A variable that will affect whether or not vowels have the possibility of
     * being included in each id.
     */
    private boolean SansVowel;

    /**
     * Instantiates an Id Generator that creates Pids primarily based on a
     * charMap. The only valid charMap characters are regex("[dlume]+"). No
     * restrictions are placed on the other parameters.
     *
     * @param prefix A sequence of characters that appear in the beginning of
     * PIDs
     * @param sansVowel Dictates whether or not vowels are allowed
     * @param charMap A sequence of characters used to configure Pids
     */
    public CustomIdGenerator(String prefix, boolean sansVowel, String charMap) {
        super(prefix);
        this.CharMap = charMap;
        this.TokenMap = new String[charMap.length()];
        this.SansVowel = sansVowel;
        this.MaxPermutation = calculatePermutations();
        
        initializeTokenMap();
    }

    /**
     * Creates Pids without regard to a natural order.
     *
     * @param amount The number of Pids to be created
     * @return A set of Pids
     */
    @Override
    public Set<Pid> randomMint(long amount) {
        // checks to see if its possible to produce or add requested amount of
        long total = calculatePermutations();
        if (total < amount) {
            throw new NotEnoughPermutationsException();
        }
        // generate ids        
        Set<Pid> pidSet = new TreeSet<>();

        // randomly generate pids using a random number generator
        for (int i = 0; i < amount; i++) {
            long value = Math.abs(Rng.nextLong()) % total;
            Pid pid = this.longToPid(value);

            // create pid and add it to the set
            while (!pidSet.add(pid)) {
                this.incrementPid(pid);
            }

            LOGGER.trace("Generated Auto Random ID: {}", pid);
        }
       
        return pidSet;
    }

    /**
     * Creates Pids in ascending order
     *
     * @param amount The number of PIDs to be created
     * @return A set of Pids
     */
    @Override
    public Set<Pid> sequentialMint(long amount) {
        // checks to see if its possible to produce or add requested amount of
        long total = calculatePermutations();
        if (total < amount) {
            throw new NotEnoughPermutationsException();
        }

        // create a set to contain Pids
        Set<Pid> pidSet = new TreeSet<>();

        long ordinal = 0;
        Pid basePid = this.longToPid(ordinal);
        for (int i = 0; i < amount; i++) {

            // copy the Name of basePid into a new Pid instance
            Pid pid = new Pid(basePid.getName());

            // add the pid to the set
            pidSet.add(pid);

            // increment the base Pid
            this.incrementPid(basePid);

            LOGGER.trace("Generated Custom Sequential ID: {}", pid);
        }       
        return pidSet;
    }

    /**
     * This method calculates and returns the total possible number of
     * permutations using the values given in the constructor.
     *
     * @return number of permutations
     */
    @Override
    final public long calculatePermutations() {
        long totalPermutations = 1;
        for (int i = 0; i < CharMap.length(); i++) {
            if (CharMap.charAt(i) == 'd') {
                totalPermutations *= 10;
            }
            else if (CharMap.charAt(i) == 'l' || CharMap.charAt(i) == 'u') {
                totalPermutations *= (SansVowel) ? 20 : 26;
            }
            else if (CharMap.charAt(i) == 'm') {
                totalPermutations *= (SansVowel) ? 40 : 52;
            }
            else if (CharMap.charAt(i) == 'e') {
                totalPermutations *= (SansVowel) ? 50 : 62;
            }
        }
        return totalPermutations;
    }

    /**
     * Initializes TokenMap to contain a String of characters at each index to
     * designate the possible values that can be assigned to each index of a
     * Pid's BaseMap.
     */
    private void initializeTokenMap() {
        for (int i = 0; i < TokenMap.length; i++) {
            // get char
            char c = CharMap.charAt(i);

            // assign each index a string of characters
            if (c == 'd') {
                TokenMap[i] = Token.DIGIT.getCharacters();
            }
            else if (c == 'l') {
                TokenMap[i] = (SansVowel) ? Token.LOWER_CONSONANTS.getCharacters()
                        : Token.LOWER_ALPHABET.getCharacters();
            }
            else if (c == 'u') {
                TokenMap[i] = (SansVowel) ? Token.UPPER_CONSONANTS.getCharacters()
                        : Token.UPPER_ALPHABET.getCharacters();
            }
            else if (c == 'm') {
                TokenMap[i] = (SansVowel) ? Token.MIXED_CONSONANTS.getCharacters()
                        : Token.MIXED_ALPHABET.getCharacters();
            }
            else {
                TokenMap[i] = (SansVowel) ? Token.MIXED_CONSONANTS_EXTENDED.getCharacters()
                        : Token.MIXED_ALPHABET_EXTENDED.getCharacters();
            }
        }
    }

    /**
     * Increments a value of a PID. If the maximum limit is reached the values
     * will wrap around.
     *
     * @param pid The pid to increment
     */
    @Override
    public void incrementPid(Pid pid) {
        long next = (this.PidToLong(pid) + 1) % this.MaxPermutation;
        pid.setName(this.longToPid(next).getName());        
    }

    /**
     * Translates an ordinal number into a Pid.
     *
     * @param ordinal The nth position of a permutation
     * @return The Pid at the nth position
     */
    @Override
    protected Pid longToPid(long ordinal) {
        StringBuilder name = new StringBuilder("");
        int fullNameLength = CharMap.length() + Prefix.length();

        long remainder = ordinal;
        for (int i = fullNameLength - 1; i >= Prefix.length(); i--) {
            String map = TokenMap[i - Prefix.length()];
            int radix = map.length();
            name.insert(0, map.charAt((int) remainder % radix));

            remainder /= radix;
        }
        
        return new Pid(Prefix + name.toString());
    }

    /**
     * Translates a Pid into an ordinal number.
     *
     * @param pid A persistent identifier
     * @return The ordinal number of the Pid
     */
    @Override
    protected long PidToLong(Pid pid) {
        String name = pid.getName();
        int fullNameLength = CharMap.length() + Prefix.length();
        int totalRadix = 1;

        long ordinal = 0;
        for (int i = fullNameLength - 1; i >= Prefix.length(); i--) {
            String map = TokenMap[i - Prefix.length()];            
            int mapIndex = map.indexOf(name.charAt(i));
            int currentRadix = map.length();
                        
            ordinal += totalRadix * mapIndex;
            totalRadix *= currentRadix;
        }

        return ordinal;
    }

    /* getters and setters */
    public String getCharMap() {
        return CharMap;
    }

    public void setCharMap(String CharMap) {
        this.CharMap = CharMap;
    }

    public boolean isSansVowel() {
        return SansVowel;
    }

    public void setSansVowel(boolean SansVowel) {
        this.SansVowel = SansVowel;
    }
}
